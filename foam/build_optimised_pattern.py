"""Selection of the theoretical pulsation patterns that best match the observations,
   with the possibility to optimise the rotation rate in the process through rescaling."""

import logging
import multiprocessing
import sys
from functools import partial
from pathlib import Path

import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from lmfit import Minimizer, Parameters

logger = logging.getLogger("logger.bop")


################################################################################
def generate_spacing_series(periods, errors=None):
    """
    Generate the period spacing series (delta P = p_(n+1) - p_n )

    Parameters
    ----------
    periods: list of floats
        Periods in units of days
     errors (optional): list of floats
        Errors on periods in units of days
    Returns
    ----------
    observed_spacings, observed_spacings_errors: tuple of lists of floats
        period spacing series (delta P values) and its errors (if supplied) in units of seconds
    """
    spacings = []
    if errors is None:
        spacings_errors = None
        for n, period_n in enumerate(periods[:-1]):
            spacings.append(abs(period_n - periods[n + 1]) * 86400.0)
    else:
        spacings_errors = []
        for n, period_n in enumerate(periods[:-1]):
            spacings.append(abs(period_n - periods[n + 1]) * 86400.0)
            spacings_errors.append(np.sqrt(errors[n] ** 2 + errors[n + 1] ** 2) * 86400.0)

    return spacings, spacings_errors


################################################################################
def construct_theoretical_puls_pattern(
    pulsation_grid_file,
    observations_file,
    method_build_series,
    pattern_starting_pulsation=[],
    which_observable="period",
    output_file="theoretical_frequency_patterns.hdf",
    asymptotic_object=None,
    estimated_rotation=None,
    grid_parameters=None,
    nr_cpu=None,
):
    """
    Construct the theoretical frequency pattern for each model in the grid, which correspond to the observed pattern.
    (Each theoretical model is a row in 'pulsation_grid_file'.)
    The rotation rate will be scaled and optimised for each theoretical pattern individually.
    This optimisation will not be performed if asymptotic_object=None.

    Parameters
    ----------
    pulsation_grid_file: string
        path to file containing input parameters of the models, and the pulsation frequencies of those models
        (as generated by function 'extract_frequency_grid' in 'functions_for_gyre').
    observations_file: string
        Path to the tsv file with observations, with a column for each observable and each set of errors.
        Column names specify the observable, and "_err" suffix denotes that it's the error.
    method_build_series: string
        way to generate the theoretical frequency pattern from each model to match the observed pattern. Options are:
            provided-pulsation: build pattern from the provided pulsation    (function 'puls_series_from_given_puls')
            highest-frequency: build pattern from the observed highest frequency    (function 'puls_series_from_given_puls')
            chisq-longest-sequence: build pattern based on longest, best matching sequence of pulsations (function 'chisq_longest_sequence')
    pattern_starting_pulsation: list of floats
        Only needed if you set method_build_series=provided-pulsation
        Value of the pulsation to start building the pattern from, one for each separated part of the pattern.
        The unit of this value needs to be the same as the observable set through which_observable.
    which_observable: string
        Observable used in the theoretical pattern construction, options are 'frequency' or 'period'.
    output_file: string
        Name (can include a path) for the file containing all the pulsation frequencies of the grid.
    asymptotic_object: asymptotic (see 'gmode_rotation_scaling')
        Object to calculate g-mode period spacing patterns in the asymptotic regime using the TAR.
    estimated_rotation: float
        Estimation of the rotation rate of the star, used as initial value in the optimisation problem.
    grid_parameters: list of string
        List of the parameters in the theoretical grid.
    nr_cpu: int
        Number of worker processes to use in multiprocessing. The default 'None' will use the number returned by os.cpu_count().
    """
    # Read in the files with observed and theoretical frequencies as pandas DataFrames
    obs_dataframe = pd.read_table(observations_file, delim_whitespace=True, header=0, index_col="index")
    theory_dataframe = pd.read_hdf(pulsation_grid_file)

    obs = np.asarray(obs_dataframe[which_observable])
    obs_err = np.asarray(obs_dataframe[f"{which_observable}_err"])

    # if frequency was filled in as 0, it indicates an interruption in the pattern
    missing_puls = np.where(obs == 0)[0]
    # remove values indicating interruptions in the pattern
    obs_without_missing = obs[obs != 0]
    # remove values indicating interruptions in the pattern
    obs_err_without_missing = obs_err[obs_err != 0]
    # Adjust indices for removed 0-values of missing frequencies
    missing_puls = [missing_puls[i] - i for i in range(len(missing_puls))]

    # split into different parts of the interrupted pattern
    obs_pattern_parts = np.split(obs_without_missing, missing_puls)
    obs_err_pattern_parts = np.split(obs_err_without_missing, missing_puls)

    # partial function fixes all parameters of the function except for 1 that is iterated over in the multiprocessing pool.
    theory_pattern_func = partial(
        theoretical_pattern_from_dfrow,
        obs=obs,
        obs_pattern_parts=obs_pattern_parts,
        obs_err_pattern_parts=obs_err_pattern_parts,
        which_observable=which_observable,
        method_build_series=method_build_series,
        pattern_starting_pulsation=pattern_starting_pulsation,
        grid_parameters=grid_parameters,
        asymptotic_object=asymptotic_object,
        estimated_rotation=estimated_rotation,
        plot_rotation_optimisation=False,
    )

    # Make the output file directory
    Path(Path(output_file).parent).mkdir(parents=True, exist_ok=True)
    # Send the rows of the dataframe iteratively to a pool of processors to get the theoretical pattern for each model
    with multiprocessing.Pool(nr_cpu) as p:
        freqs = p.imap(theory_pattern_func, theory_dataframe.iterrows())
        header_parameters = ["rot", "rot_err"] + grid_parameters

        for i in range(1, obs_dataframe.shape[0] + 1):
            if i - 1 in np.where(obs_dataframe.index == "f_missing")[0]:
                f = f"{which_observable}_missing"
            else:
                f = f"{which_observable}{i}"
            header_parameters.append(f.strip())

        data = []
        for line in freqs:
            data.append(line)

    df = pd.DataFrame(data=data, columns=header_parameters)
    df.to_hdf(f"{output_file}", "selected_puls_grid", format="table", mode="w")


# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def theoretical_pattern_from_dfrow(
    summary_grid_row,
    obs,
    obs_pattern_parts,
    obs_err_pattern_parts,
    which_observable,
    method_build_series,
    pattern_starting_pulsation=[],
    asymptotic_object=None,
    estimated_rotation=None,
    plot_rotation_optimisation=False,
    grid_parameters=None,
):
    """
    Extract model parameters and a theoretical pulsation pattern from a row of the dataFrame that contains all model parameters and pulsation frequencies.

    Parameters
    ----------
    summary_grid_row: tuple, made of (int, pandas series)
        tuple returned from pandas.iterrows(), first tuple entry is the row index of the pandas dataFrame
        second tuple entry is a pandas series, containing a row from the pandas dataFrame.
        (This row holds model parameters and pulsation frequencies.)
    obs: numpy array, dtype=float
        Array of observed frequencies or periods. (Ordered increasing in frequency.)
    obs_pattern_parts : list of numpy array, dtype=float
        Holds a numpy array (with the observed frequencies or periods) per split off part
        of the observed pattern if it is interrupted.
        The list contains only one array if the observed pattern is uninterrupted.
    obs_err_pattern_parts : list of numpy array, dtype=float
        The errors on the data in obs_pattern_parts.
    which_observable: string
        Which observables are used in the pattern building, options are 'frequency' or 'period'.
    method_build_series: string
        way to generate the theoretical frequency pattern from each model
        to match the observed pattern. Options are:
            provided-pulsation: build pattern from the provided pulsation    (function 'puls_series_from_given_puls')
            highest-frequency: build pattern from the observed highest frequency    (function 'puls_series_from_given_puls')
            chisq-longest-sequence: build pattern based on longest, best matching sequence of pulsations    (function 'chisq_longest_sequence')
    pattern_starting_pulsation: list of floats
        Only needed if you set method_build_series=provided-pulsation
        Value of the pulsation to start building the pattern from, one for each separated part of the pattern.
        The unit of this value needs to be the same as the observable set through which_observable.
    asymptotic_object: asymptotic (see 'gmode_rotation_scaling')
        Object to calculate g-mode period spacing patterns in the asymptotic regime using the TAR.
    estimated_rotation: float
        Estimation of the rotation rate of the star, used as initial value in the optimisation problem.
    grid_parameters: list of string
        List of the parameters in the theoretical grid.

    Returns
    ----------
    list_out: list of float
        The input parameters and pulsation frequencies of the theoretical pattern
        (or periods, depending on 'which_observable').
    """
    # all keys containing n_pg (these are all the radial orders)
    freqs = np.asarray(summary_grid_row[1].filter(like="n_pg"))
    # array with radial orders
    orders = np.asarray([int(o.replace("n_pg", "")) for o in summary_grid_row[1].filter(like="n_pg").index])
    orders = orders[~np.isnan(freqs)]
    # remove all entries that are NaN in the numpy array (for when the models have a different amount of computed modes)
    freqs = freqs[~np.isnan(freqs)]

    # Check if pattern_starting_pulsation has enough entries to not truncate other parts in the zip function.
    if len(obs_pattern_parts) != len(pattern_starting_pulsation):
        if method_build_series == "provided-pulsation":
            sys.exit(
                logger.error(
                    "Amount of pulsations specified to build patterns from is not equal to the amount of split-off parts in the pattern."
                )
            )
        # Content of pattern_starting_pulsation doesn't matter if it's not used to build the pattern.
        else:
            # We only care about the length if the method doesn't use specified pulsations.
            pattern_starting_pulsation = [None] * len(obs_pattern_parts)

    # In this case, rescaling nor optimisation will happen
    if asymptotic_object is None:
        residual = rescale_rotation_and_select_theoretical_pattern(
            None,
            asymptotic_object,
            estimated_rotation,
            freqs,
            orders,
            obs,
            obs_pattern_parts,
            obs_err_pattern_parts,
            which_observable,
            method_build_series,
            pattern_starting_pulsation,
        )

        list_out = [estimated_rotation, 0]
        for parameter in grid_parameters:
            list_out.append(summary_grid_row[1][parameter])

        selected_pulsations = obs + residual
        list_out.extend(selected_pulsations)

    else:
        # Optimise the rotation rate and get the pulsations at that rotation rate
        params = Parameters()
        params.add("rotation", value=estimated_rotation, min=1e-5)
        # Fit rotation to observed pattern with the default leastsq algorithm
        optimise_rotation = Minimizer(
            rescale_rotation_and_select_theoretical_pattern,
            params,
            fcn_args=(
                asymptotic_object,
                estimated_rotation,
                freqs,
                orders,
                obs,
                obs_pattern_parts,
                obs_err_pattern_parts,
                which_observable,
                method_build_series,
                pattern_starting_pulsation,
            ),
        )

        result_minimizer = optimise_rotation.minimize()

        # Search from second initial value, which is as separated from the first solution as the first initial guess.
        search_second_initial_value = 2 * result_minimizer.params["rotation"].value - estimated_rotation
        params = Parameters()
        params.add("rotation", value=search_second_initial_value, min=1e-5)
        optimise_rotation = Minimizer(
            rescale_rotation_and_select_theoretical_pattern,
            params,
            fcn_args=(
                asymptotic_object,
                estimated_rotation,
                freqs,
                orders,
                obs,
                obs_pattern_parts,
                obs_err_pattern_parts,
                which_observable,
                method_build_series,
                pattern_starting_pulsation,
            ),
        )

        result_minimizer2 = optimise_rotation.minimize()
        # Select the minimizer with the initial guess that resulted in the best fit.
        if result_minimizer2.chisqr < result_minimizer.chisqr:
            result_minimizer = result_minimizer2

        optimised_pulsations = result_minimizer.residual + obs

        if result_minimizer.message != "Fit succeeded.":
            logger.warning(
                f"""Fitting rotation did not succeed: {result_minimizer.message}
                            for model {summary_grid_row[1].drop(summary_grid_row[1].filter(regex='n_pg').index).drop('rot').to_dict()} using method: {method_build_series}
                            rotation found: {result_minimizer.params['rotation'].value} with error: {result_minimizer.params['rotation'].stderr}"""
            )

        if plot_rotation_optimisation:
            fig1, ax1 = plt.subplots()
            if which_observable == "frequency":
                obsperiod = 1 / obs
                optimised_periods = 1 / optimised_pulsations
            else:
                obsperiod = obs
                optimised_periods = optimised_pulsations

            # Recombine observational errors in one array
            combined_obs_err = []
            for obs_err_part in obs_err_pattern_parts:
                if len(combined_obs_err) > 0:
                    combined_obs_err.extend([0])
                combined_obs_err.extend(obs_err_part)
            combined_obs_err = np.asarray(combined_obs_err)

            spacings = generate_spacing_series(obsperiod, combined_obs_err)
            ax1.errorbar(obsperiod[:-1], spacings[0], fmt="o", yerr=spacings[1], label="obs", color="blue", alpha=0.8)
            ax1.plot(obsperiod[:-1], spacings[0], color="blue")
            ax1.plot(
                optimised_periods[:-1],
                generate_spacing_series(optimised_periods)[0],
                "*",
                ls="solid",
                color="orange",
                label="optimised",
            )
            ax1.plot(
                1 / freqs[:-1], generate_spacing_series(1 / freqs)[0], ".", ls="solid", label="initial", color="green"
            )

            fig2, ax2 = plt.subplots()

            ax2.errorbar(obs, obs, fmt="o", xerr=combined_obs_err, label="obs", color="blue", alpha=0.8)
            ax2.plot(optimised_periods, optimised_periods, "*", color="orange", label="optimised")
            ax2.plot(1 / freqs, 1 / freqs, ".", label="initial", color="green")

            ax1.legend(prop={"size": 14})
            ax2.legend(prop={"size": 14})
            ax1.set_title(
                f"initial omega = {estimated_rotation}, optimised omega = {result_minimizer.params['rotation'].value}"
            )
            ax2.set_title(
                f"initial omega = {estimated_rotation}, optimised omega = {result_minimizer.params['rotation'].value}"
            )
            plt.show()

        # Create list with rotation, its error, all the input parameters, and the optimised pulsations
        list_out = [result_minimizer.params["rotation"].value, result_minimizer.params["rotation"].stderr]
        for parameter in grid_parameters:
            list_out.append(summary_grid_row[1][parameter])
        list_out.extend(optimised_pulsations)

    return list_out


# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def rescale_rotation_and_select_theoretical_pattern(
    params,
    asymptotic_object,
    estimated_rotation,
    freqs_input,
    orders,
    obs,
    obs_pattern_parts,
    obs_err_pattern_parts,
    which_observable,
    method_build_series,
    pattern_starting_pulsation,
):
    """
    If rotation is not optimised in the modelling, asymptotic_object should be set to 'None' and
    this function will just select a theoretical pulsation pattern based on the specified method.
    If asymptotic_object is supplied, the rotation will be optimised and this will be the
    objective function for the lmfit Minimizer class to minimise the output of.
    Rescales the theoretical pulsation pattern using the asymptotic object from
    'gmode_rotation_scaling', and selects a theoretical pulsation pattern based
    on the specified method.

    Parameters
    ----------
    params: Parameter (object of lmfit)
        The parameter used to optimise the fit. In this case rotation in units of 1/day.
    asymptotic_object: asymptotic (see 'gmode_rotation_scaling')
        Object to calculate g-mode period spacing patterns in the asymptotic regime using the TAR.
    estimated_rotation: float
        Estimated rotation rate in units of 1/day. Used as initial value in the optimisation problem.
    freqs_input: numpy array, dtype=float
        Array of the frequencies as computed by GYRE, to be scaled to the optimal rotation rate.
    orders: numpy array, dtype=int
        Array with the radial orders of the theoretical input frequencies.
    obs: numpy array, dtype=float
        Array of observed frequencies or periods. (Ordered increasing in frequency.)
    obs_pattern_parts: list of numpy array, dtype=float
        Holds a numpy array with observed frequencies or periods
        per split off part of the observed pattern if it is interrupted.
        The list contains only one array if the observed pattern is uninterrupted.
    obs_err_pattern_parts: list of numpy array, dtype=float
        The errors on obs_pattern_parts
    which_observable: string
        Which observables are used in the pattern building, options are 'frequency' or 'period'.
    method_build_series: string
        way to generate the theoretical frequency pattern from each model
        to match the observed pattern. Options are:
            provided-pulsation: build pattern from the provided pulsation    (function 'puls_series_from_given_puls')
            highest-frequency: build pattern from the observed highest frequency    (function 'puls_series_from_given_puls')
            chisq-longest-sequence: build pattern based on longest, best matching sequence of pulsations    (function 'chisq_longest_sequence')
    pattern_starting_pulsation: list of floats
        Only needed if you set method_build_series=provided-pulsation
        Value of the pulsation to start building the pattern from, one for each separated part of the pattern.
        The unit of this value needs to be the same as the observable set through which_observable.

    Returns
    ----------
    (output_pulsations - obs): numpy array, dtype=float
        Differences between the scaled pulsations and the observations.
        The array to be minimised by the lmfit Minimizer if rotation is optimised.
    """
    if asymptotic_object is not None:
        v = params.valuesdict()
        # To avoid division by zero in scale_pattern
        if estimated_rotation == 0:
            estimated_rotation = 1e-99
        freqs = asymptotic_object.scale_pattern(freqs_input / u.d, estimated_rotation / u.d, v["rotation"] / u.d) * u.d
        # convert astropy quantities back to floats
        freqs = np.asarray(freqs, dtype=np.float64)
    else:
        freqs = freqs_input

    periods = 1 / freqs

    output_pulsations = []
    for obs_part, obs_err_part, pattern_starting_pulsation_part in zip(
        obs_pattern_parts, obs_err_pattern_parts, pattern_starting_pulsation
    ):
        # To indicate interruptions in the pattern
        if len(output_pulsations) > 0:
            output_pulsations.append(0)

        if which_observable == "frequency":
            # remove frequencies that were already chosen in a different, split-off part of the pattern
            if len(output_pulsations) > 0:
                # If input is in increasing radial order (decreasing n_pg, since n_pg is negative for g-modes)
                if orders[1] == orders[0] - 1:
                    # index -2 to get lowest, non-zero freq
                    np.delete(freqs, np.where(freqs >= output_pulsations[-2]))
                # If input is in decreasing radial order
                else:
                    np.delete(freqs, np.where(freqs <= max(output_pulsations)))
            theory_value = freqs
            obs_period = 1 / obs_part
            obs_period_err = obs_err_part / obs_part**2
            highest_obs_freq = max(obs_part)

        elif which_observable == "period":
            # remove periods that were already chosen in a different, split-off part of the pattern
            if len(output_pulsations) > 0:
                # If input is in increasing radial order (decreasing n_pg, since n_pg is negative for g-modes)
                if orders[1] == orders[0] - 1:
                    np.delete(periods, np.where(periods <= max(output_pulsations)))
                # If input is in decreasing radial order
                else:
                    # index -2 to get lowest, non-zero period
                    np.delete(periods, np.where(periods >= output_pulsations[-2]))
            theory_value = periods
            obs_period = obs_part
            obs_period_err = obs_err_part
            # highest frequency is lowest period
            highest_obs_freq = min(obs_part)
        else:
            sys.exit(logger.error("Unknown observable to fit"))

        if method_build_series == "provided-pulsation":
            selected_theoretical_pulsations = puls_series_from_given_puls(
                theory_value, obs_part, pattern_starting_pulsation_part
            )
        elif method_build_series == "highest-frequency":
            selected_theoretical_pulsations = puls_series_from_given_puls(theory_value, obs_part, highest_obs_freq)
        elif method_build_series == "chisq-longest-sequence":
            series_chi2, final_theoretical_periods, corresponding_orders = chisq_longest_sequence(
                periods, orders, obs_period, obs_period_err
            )
            if which_observable == "frequency":
                selected_theoretical_pulsations = 1 / np.asarray(final_theoretical_periods)
            elif which_observable == "period":
                selected_theoretical_pulsations = final_theoretical_periods
        else:
            sys.exit(logger.error(f"Unrecognised method to build pulsation series: {method_build_series}"))

        output_pulsations.extend(selected_theoretical_pulsations)

    return output_pulsations - obs


################################################################################
def puls_series_from_given_puls(theory_in, obs, obs_to_build_from, plot=False):
    """
    Generate a theoretical pulsation pattern (can be in frequency or period) from the given observations.
    Build consecutively in radial order, starting from the theoretical value closest to the provided observational value.

    Parameters
    ----------
    theory_in: numpy array, dtype=float
        Array of theoretical frequencies or periods.
    obs: numpy array, dtype=float
        Array of observed frequencies or periods.
    obs_to_build_from: float
        observed frequency or period value to start building the pattern from.
    plot: boolean
        Make a period spacing diagram for the constructed series.

    Returns
    ----------
    theory_sequence: list of float
        The constructed theoretical frequency pattern
    """
    # get index of observation to build the series from
    nth_obs = np.where(obs == obs_to_build_from)[0][0]
    # search theoretical freq closest to the given observed one
    diff = abs(theory_in - obs_to_build_from)
    # get index of this theoretical frequency
    index = np.where(diff == min(diff))[0][0]

    # Insert a value of -1 if observations miss a theoretical counterpart in the beginning
    theory_sequence = []
    if (index - nth_obs) < 0:
        for i in range(abs((index - nth_obs))):
            theory_sequence.append(-1)
        theory_sequence.extend(theory_in[0 : index + (len(obs) - nth_obs)])
    else:
        theory_sequence.extend(theory_in[index - nth_obs : index + (len(obs) - nth_obs)])

    # Insert a value of -1 if observations miss a theoretical counterpart at the end
    if index + (len(obs) - nth_obs) > len(theory_in):
        for i in range((index + (len(obs) - nth_obs)) - len(theory_in)):
            theory_sequence.append(-1)

    if plot is True:
        fig = plt.figure()
        ax = fig.add_subplot(111)
        theory = np.asarray(theory_sequence)
        ax.plot((1 / obs)[::-1][:-1], np.diff((1 / obs)[::-1]) * 86400, "ko", lw=1.5, linestyle="-")
        ax.plot(
            (1.0 / theory)[::-1][:-1],
            -np.diff(1.0 / theory)[::-1] * 86400,
            "ko",
            color="blue",
            lw=1.5,
            linestyle="--",
            markersize=6,
            markeredgewidth=0.0,
        )
        plt.show()

    return theory_sequence


################################################################################
def chisq_longest_sequence(theory_periods, orders, obs_periods, obs_periods_errors):
    """
    Method to extract the theoretical pattern that best matches the observed one.
    Match each observed mode period to its best matching theoretical counterpart,
    and adopt the longest sequence of consecutive modes found this way.
    In case of multiple mode series with the same length, a final pattern selection
    is made based on the best (chi-square) match between theory and observations.

    Parameters
    ----------
    theory_periods : numpy array, dtype=float
        Theoretical periods and their radial orders.
    orders : numpy array, dtype=int
        Radial orders corresponding to the periods in theory_periods.
    obs_periods: numpy array, dtype=float
        Observational periods.
    obs_periods_errors: numpy array, dtype=float
        The errors on obs_periods.

    Returns
    ----------
    series_chi2: float
        chi2 value of the selected theoretical frequencies.
    final_theoretical_periods: numpy array, dtype=float
        The selected theoretical periods that best match the observed pattern.
    corresponding_orders: list of integers
        The radial orders of the returned theoretical periods.
    """
    if len(theory_periods) < len(obs_periods):
        return 1e16, [-1.0 for i in range(len(obs_periods))], [-1 for i in range(len(obs_periods))]
    else:
        # Find the best matches per observed period
        pairs_orders = []
        for ii, period in enumerate(obs_periods):
            ## Chi_squared array definition
            chi_sqrs = np.array(
                [((period - theory_period) / obs_periods_errors[ii]) ** 2 for theory_period in theory_periods]
            )

            ## Locate the theoretical frequency (and accompanying order) with the best chi2
            min_ind = np.where(chi_sqrs == min(chi_sqrs))[0]
            best_match = theory_periods[min_ind][0]
            best_order = orders[min_ind][0]

            ## Toss everything together for bookkeeping
            pairs_orders.append([period, best_match, int(best_order), chi_sqrs[min_ind][0]])

        pairs_orders = np.array(pairs_orders)

        # If input is in increasing radial order (decreasing n_pg, since n_pg is negative for g-modes)
        if orders[1] == orders[0] - 1:
            increase_or_decrease = -1
        # If input is in decreasing radial order
        else:
            increase_or_decrease = 1

        sequences = []
        ## Go through all pairs of obs and theoretical frequencies and
        ## check if the next observed frequency has a corresponding theoretical frequency
        ## with the consecutive radial order.
        current = []
        lp = len(pairs_orders[:-1])
        for ii, sett in enumerate(pairs_orders[:-1]):
            if abs(sett[2]) == abs(pairs_orders[ii + 1][2]) + increase_or_decrease:
                current.append(sett)
            # If not consecutive radial order, save the current sequence and start a new one.
            else:
                current.append(sett)
                sequences.append(np.array(current).reshape(len(current), 4))
                current = []
            if ii == lp - 1:
                current.append(sett)
                sequences.append(np.array(current).reshape(len(current), 4))
                current = []
        len_list = np.array([len(x) for x in sequences])
        longest = np.where(len_list == max(len_list))[0]

        ## Test if there really is one longest sequence
        if len(longest) == 1:
            lseq = sequences[longest[0]]

        ## if not, pick, of all the sequences with the same length, the best based on chi2
        else:
            scores = [np.sum(sequences[ii][:, -1]) / len(sequences[ii]) for ii in longest]
            min_score = np.where(scores == min(scores))[0][0]
            lseq = sequences[longest[min_score]]

        obs_ordering_ind = np.where(obs_periods == lseq[:, 0][0])[0][0]
        thr_ordering_ind = np.where(theory_periods == lseq[:, 1][0])[0][0]

        ordered_theoretical_periods = []
        corresponding_orders = []

        thr_ind_start = thr_ordering_ind - obs_ordering_ind
        thr_ind_current = thr_ind_start

        for i, oper in enumerate(obs_periods):
            thr_ind_current = thr_ind_start + i
            if thr_ind_current < 0:
                tper = -1
                ordr = -1
            elif thr_ind_current >= len(theory_periods):
                tper = -1
                ordr = -1
            else:
                tper = theory_periods[thr_ind_current]
                ordr = orders[thr_ind_current]
            ordered_theoretical_periods.append(tper)
            corresponding_orders.append(ordr)

        final_theoretical_periods = np.array(ordered_theoretical_periods)

        obs_series, obs_series_errors = generate_spacing_series(obs_periods, obs_periods_errors)
        thr_series, _ = generate_spacing_series(final_theoretical_periods)

        obs_series = np.array(obs_series)
        obs_series_errors = np.array(obs_series_errors)
        thr_series = np.array(thr_series)

        series_chi2 = np.sum(((obs_series - thr_series) / obs_series_errors) ** 2) / len(obs_series)

        return series_chi2, final_theoretical_periods, corresponding_orders
